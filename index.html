<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Быстрая публикация — компактная ссылка (без сервера)</title>
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Arial;max-width:900px;margin:20px auto;padding:16px}
  h1{margin-top:0}
  textarea{width:100%;height:280px;font-family:monospace;font-size:13px;padding:10px;border-radius:8px;border:1px solid #ddd;box-sizing:border-box}
  .row{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
  input, button{padding:10px;border-radius:8px;border:1px solid #bbb;background:#fff}
  button{cursor:pointer}
  .result{margin-top:12px;padding:12px;background:#fafafa;border-radius:8px;border:1px solid #eee;word-break:break-all}
  iframe{width:100%;height:360px;border:1px solid #ccc;border-radius:8px;margin-top:10px}
  small{color:#666}
</style>
</head>
<body>
<h1>Публикация — компактная ссылка (без сервера)</h1>
<p>Вставь HTML → жми «Создать ссылку» → получаешь компактную ссылку. Без шифров, без паролей — то, что вставил, тот и увидит.</p>

<div id="app">
  <label><strong>HTML-код:</strong></label>
  <textarea id="code" placeholder="&lt;h1&gt;Привет&lt;/h1&gt;"></textarea>

  <div class="row">
    <button id="publish">Создать ссылку</button>
    <button id="previewBtn">Показать предпросмотр</button>
    <button id="clearBtn">Очистить</button>
  </div>

  <div class="result" id="result" style="display:none"></div>

  <div id="previewBox" style="display:none">
    <h3>Предпросмотр</h3>
    <iframe id="preview"></iframe>
  </div>

  <p style="margin-top:12px"><small>Замечание: ссылка содержит весь код (сжатый) в хеше `#`. Отправляй ссылку получателю — он откроет страницу без сервера. Для очень больших страниц ссылка может получиться длинной.</small></p>
</div>

<div id="viewer" style="display:none"></div>

<script>
/* ---- LZ-String: compressToEncodedURIComponent & decompressFromEncodedURIComponent ----
   Минимально необходимая реализация (взята из общеизвестной LZ-String библиотеки). */
const LZ = (function(){
  // helper: compress to encodedURIComponent
  function compressToEncodedURIComponent(input) {
    if (input == null) return "";
    return _compress(input, 6, function(a){ return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$".charAt(a); });
  }
  function decompressFromEncodedURIComponent(input) {
    if (input == null) return "";
    if (input == "") return null;
    input = input.replace(/ /g, "+");
    return _decompress(input.length, 32, function(index) { return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$".indexOf(input.charAt(index)); });
  }
  /* internals (compressed implementation) */
  function _compress(uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed == null) return "";
    let i, value,
      context_dictionary = {},
      context_dictionaryToCreate = {},
      context_c = "",
      context_wc = "",
      context_w = "",
      context_enlargeIn = 2, // Compensate for the first entry which should not count
      context_dictSize = 3,
      context_numBits = 2,
      context_data = [],
      context_data_val = 0,
      context_data_position = 0;

    for (i = 0; i < uncompressed.length; i += 1) {
      context_c = uncompressed.charAt(i);
      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {
        context_dictionary[context_c] = context_dictSize++;
        context_dictionaryToCreate[context_c] = true;
      }

      context_wc = context_w + context_c;
      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {
        context_w = context_wc;
      } else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
          if (context_w.charCodeAt(0) < 256) {
            for (value = 0; value < context_numBits; value++) {
              context_data_val = (context_data_val << 1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else context_data_position++;
            }
            value = context_w.charCodeAt(0);
            for (let j=0;j<8;j++) {
              context_data_val = (context_data_val << 1) | (value & 1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else context_data_position++;
              value = value >> 1;
            }
          } else {
            value = 1;
            for (let j=0;j<context_numBits;j++) {
              context_data_val = (context_data_val << 1) | value;
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else context_data_position++;
            }
            value = context_w.charCodeAt(0);
            for (let j=0;j<16;j++) {
              context_data_val = (context_data_val << 1) | (value & 1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else context_data_position++;
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (let j=0;j<context_numBits;j++) {
            context_data_val = (context_data_val << 1) | (value & 1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else context_data_position++;
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        // Add wc to the dictionary.
        context_dictionary[context_wc] = context_dictSize++;
        context_w = String(context_c);
      }
    }

    if (context_w !== "") {
      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
        if (context_w.charCodeAt(0) < 256) {
          for (let j = 0; j < context_numBits; j++) {
            context_data_val = (context_data_val << 1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else context_data_position++;
          }
          value = context_w.charCodeAt(0);
          for (let j = 0; j < 8; j++) {
            context_data_val = (context_data_val << 1) | (value & 1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else context_data_position++;
            value = value >> 1;
          }
        } else {
          value = 1;
          for (let j = 0; j < context_numBits; j++) {
            context_data_val = (context_data_val << 1) | value;
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else context_data_position++;
          }
          value = context_w.charCodeAt(0);
          for (let j = 0; j < 16; j++) {
            context_data_val = (context_data_val << 1) | (value & 1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else context_data_position++;
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        delete context_dictionaryToCreate[context_w];
      } else {
        value = context_dictionary[context_w];
        for (let j = 0; j < context_numBits; j++) {
          context_data_val = (context_data_val << 1) | (value & 1);
          if (context_data_position == bitsPerChar-1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else context_data_position++;
          value = value >> 1;
        }
      }
      context_enlargeIn--;
      if (context_enlargeIn == 0) {
        context_enlargeIn = Math.pow(2, context_numBits);
        context_numBits++;
      }
    }

    // Mark the end of the stream
    value = 2;
    for (let j = 0; j < context_numBits; j++) {
      context_data_val = (context_data_val << 1) | (value & 1);
      if (context_data_position == bitsPerChar-1) {
        context_data_position = 0;
        context_data.push(getCharFromInt(context_data_val));
        context_data_val = 0;
      } else context_data_position++;
      value = value >> 1;
    }

    // Flush the last char
    while (true) {
      context_data_val = (context_data_val << 1);
      if (context_data_position == bitsPerChar-1) {
        context_data.push(getCharFromInt(context_data_val));
        break;
      }
      else context_data_position++;
    }
    return context_data.join('');
  }

  function _decompress(length, resetValue, getNextValue) {
    let dictionary = [],
        enlargeIn = 4,
        dictSize = 4,
        numBits = 3,
        entry = "",
        result = [],
        i, w, bits, resb, maxpower, power,
        c,
        data = {val:getNextValue(0), position:resetValue, index:1};

    for (i = 0; i < 3; i += 1) {
      dictionary[i] = i;
    }

    bits = 0;
    maxpower = Math.pow(2,2);
    power = 1;
    while (power != maxpower) {
      resb = data.val & data.position;
      data.position >>= 1;
      if (data.position == 0) {
        data.position = resetValue;
        data.val = getNextValue(data.index++);
      }
      bits |= (resb>0?1:0) * power;
      power <<= 1;
    }

    switch (next = bits) {
      case 0:
        bits = 0;
        maxpower = Math.pow(2,8);
        power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb>0?1:0) * power;
          power <<= 1;
        }
        c = String.fromCharCode(bits);
        break;
      case 1:
        bits = 0;
        maxpower = Math.pow(2,16);
        power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb>0?1:0) * power;
          power <<= 1;
        }
        c = String.fromCharCode(bits);
        break;
      case 2:
        return "";
    }
    dictionary[3] = c;
    w = c;
    result.push(c);
    while (true) {
      if (data.index > length) {
        return "";
      }

      bits = 0;
      maxpower = Math.pow(2,numBits);
      power = 1;
      while (power != maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position == 0) {
          data.position = resetValue;
          data.val = getNextValue(data.index++);
        }
        bits |= (resb>0?1:0) * power;
        power <<= 1;
      }

      switch (c = bits) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0?1:0) * power;
            power <<= 1;
          }

          dictionary[dictSize++] = String.fromCharCode(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0?1:0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = String.fromCharCode(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 2:
          return result.join('');
      }

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

      if (dictionary[c]) {
        entry = dictionary[c];
      } else {
        if (c === dictSize) {
          entry = w + w.charAt(0);
        } else {
          return null;
        }
      }
      result.push(entry);

      // Add w+entry[0] to the dictionary.
      dictionary[dictSize++] = w + entry.charAt(0);
      enlargeIn--;

      w = entry;

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }
    }
  }

  return { compressToEncodedURIComponent, decompressFromEncodedURIComponent };
})();

/* ---- UI logic ---- */
const codeEl = document.getElementById('code');
const publishBtn = document.getElementById('publish');
const resultBox = document.getElementById('result');
const previewBox = document.getElementById('previewBox');
const previewFrame = document.getElementById('preview');
const previewBtn = document.getElementById('previewBtn');
const clearBtn = document.getElementById('clearBtn');

publishBtn.onclick = () => {
  const html = codeEl.value || '';
  if (!html.trim()) return alert('Введите HTML код!');
  // сжимаем и кодируем так, чтобы безопасно помещать в URL (encodeURIComponent-подобный алфавит)
  const compressed = LZ.compressToEncodedURIComponent(html);
  const baseUrl = location.origin + location.pathname;
  const share = baseUrl + '#e=' + compressed;

  resultBox.style.display = 'block';
  resultBox.innerHTML = `
    <strong>Готово — скопируй ссылку и отправь:</strong><br>
    <input id="linkField" style="width:100%;padding:8px;margin-top:6px" value="${share}" readonly />
    <div style="margin-top:8px">
      <button id="copyBtn">Копировать ссылку</button>
      <button id="openBtn">Открыть в новой вкладке</button>
      <button id="shortWarn" style="display:none">Link too long</button>
    </div>
    <p style="margin-top:8px"><small>Длина ссылки: ${share.length} символов</small></p>
  `;

  document.getElementById('copyBtn').onclick = () => {
    const lf = document.getElementById('linkField');
    lf.select(); lf.setSelectionRange(0, 999999);
    document.execCommand('copy');
    alert('Ссылка скопирована.');
  };
  document.getElementById('openBtn').onclick = () => window.open(share, '_blank');

  // показать превью автоматически
  previewBox.style.display = 'block';
  previewFrame.srcdoc = html;

  // предупреждение если ссылка очень длинная (>2000 символов — может не работать в некоторых мессенджерах)
  if (share.length > 2000) {
    const warn = document.getElementById('shortWarn');
    warn.style.display='inline-block';
    warn.textContent = 'Внимание: ссылка длинная (может плохо отправляться в некоторых мессенджерах)';
  }
};

previewBtn.onclick = () => {
  const html = codeEl.value || '';
  if (!html.trim()) return alert('Введите HTML код для предпросмотра.');
  previewBox.style.display = 'block';
  previewFrame.srcdoc = html;
};

clearBtn.onclick = () => {
  if (!confirm('Очистить поле?')) return;
  codeEl.value = '';
  resultBox.style.display = 'none';
  previewBox.style.display = 'none';
};

/* ---- При открытии ссылки: распакуем и покажем только страницу (без UI) ---- */
(function handleOpen() {
  const hash = location.hash || '';
  if (!hash) return; // обычный режим — показываем UI
  const params = new URLSearchParams(hash.replace(/^#/, ''));
  if (!params.has('e')) return;
  const enc = params.get('e');
  try {
    const html = LZ.decompressFromEncodedURIComponent(enc);
    if (html == null) throw new Error('Не удалось распаковать содержимое.');
    // Заменим страницу на чистый контент (чтобы не показывать UI)
    document.documentElement.innerHTML = html;
    // Если нужно, можно принудительно установить base href чтобы относительные пути работали:
    // const base = document.createElement('base'); base.href = location.href.split('#')[0]; document.head.appendChild(base);
  } catch (e) {
    // если что-то не так — оставим UI и покажем ошибку
    console.error(e);
    alert('Ошибка: не удалось распаковать страницу из ссылки.');
  }
})();
</script>
</body>
</html>
